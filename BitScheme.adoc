= BitScheme Tutorial

BitScheme is a lightweight data format for describing arbitrary sequences of binary data ("bitstreams", like those used for programming FPGAs). It also doubles as a scripting language for manipulating those bitstreams -- what is sometimes called a DREADFUL (Diversely Rendered Executable Abstract Data Format UnLanguage).

BitScheme files use `bitscheme` as the file extension, and must begin with a hashbang containing that string,  e.g.:
```
#!/use/bin/env bitscheme
```

While you can write your parsers in other languages to read the BitScheme format, BitScheme files can also be executed directly from the command line. With no arguments, `bitscheme` will write a bitstream to stdout. If passed an input bitstream, they will pattern match against it to generate symbolic code that can recreate that bitstream.

BitScheme can also be run as a REPL, with `; ` as the input prompt and `# ` for the output. That is the format we will use for examples in this document.

== Syntax

BitScheme syntax is mostly just Identifiers and Grouping.

=== Identifiers
==== Literals

The simplest Identifiers are Literals, e.g.:
```
; 12345 # Decimal
# 12345
; 0b101 # Binary
# 0b101
; `Hello' # String (quoted, utf-8)
# `Hello'
; \5\Hello # NetString (sized in bytes)
# \5\Hello
```
You can also use triple-backquotes for docstrings in https://asciidoctor.org[asciidoc] format. If you pass a '.adoc' file to bitscheme, it will prepend the backquotes, execute the code blocks, and warn if the evaluated input does not match the expected output.

Comment strings (using '#') are also considered a type of Literal:
```
; 1234 # trailing comment
; #  inline comment # 4321

```

==== Expressions

Identifiers can be combined into Expressions. The default behavior is concatenation:
```
; 0b1101 0b0110
# 0b11010110
; `Hello' ` World'
# `Hello World'
```
==== Symbols

BitScheme also supports Symbolic Identifiers, which use prefix sigils for different usages:

```
; .the-answer 42; # .Name (setter)
; the-answer # Value (getter)
# 42
; ther-answer
# $ther-answer # $Error
; @the-answer 7; # @Reference (reset)

```

Symbols with only non-alphanumeric characters (e.g., '+') are called Operators. There are four universal binary Operators in the standard library, which can be used with any Value:
- `?` if-then
- `:` if-else
- `&` map
- `|` reduce


=== Grouping

Grouping is done using Terminals (comma `,`, semicolon `;`, and newline `\n`) and the four pairs of Delimiters:
```
; [1, 2, 3] # [] Sequence
# [1, 2, 3]
; (0b1 0b0), # () Expression
# 0b10
; .Proc {0b1 0b0}; # {} Closure
; .nil ();
; .all <>;
; .Bit <nil, all>; # <> Schema
```

== Schemas

Schemas are a novel feature of `bitscheme`, sort of a cross between type signatures and regular expressions.  Syntactically they are ordinary Groupings, so they are easy to compose and refactor.

The three simple Schemas resemble C types, though they actually define an interface rather than require a specific representation:
```
; .Enum <1,2,3>; # Enumerated list of valid values
; .Byte <8 Bit>; # Fixed-length sequences
; .BitStream <[Bit]>; # Variable-length Sequence of a specific type
```
The Schema constrains which values can be bound to a Symbol, and can be retrieved via the `<>` property.
```
; @Enum 2;
; Enum
# 2
; Enum.<>
# <1,2,3>
; @Enum 4
# $Enum<1,2,3> 4
```

Schemas can also act directly to extract or rebind values from compound sequences:

```
; <.x, .z> [.x 1; .y 2; .z 3;] # Selector
# [1, 3]
; <.b <Bit>> [<>, (), <>]
# [.b <>;]

```


== Example: RISC V
