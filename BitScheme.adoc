= BitScheme Tutorial

BitScheme is a lightweight data format for describing arbitrary sequences of binary data ("bitstreams", like those used for programming FPGAs). It also doubles as a scripting language for manipulating those bitstreams -- what is sometimes called a DREADFUL (Diversely Rendered Executable Abstract Data Format UnLanguage).

BitScheme files use `bitscheme` as the file extension, and must begin with a hashbang containing that string,  e.g.:
```
#!/use/bin/env bitscheme
```

While you can write your parsers in other languages to read the BitScheme format, BitScheme files can also be executed directly from the command line. With no arguments, `bitscheme` will write a bitstream to stdout. If passed an input bitstream, they will pattern match against it to generate symbolic code that can recreate that bitstream.

BitScheme can also be run as a REPL, with `; ` as the input prompt and `# ` for the output. That is the format we will use for examples in this document.

== Syntax

BitScheme syntax is mostly just Identifiers and Grouping.

=== Identifiers
==== Literals

The simplest Identifiers are Literals, e.g.:
```
; 12345 # Decimal
# 12345
; 0b101 # Binary
# 0b101
; `Hello' # String (quoted, utf-8)
# `Hello'
; \5\Hello # NetString (sized in bytes)
# \5\Hello
```
You can also use triple-backquotes for docstrings in https://asciidoctor.org[asciidoc] format. If you pass a '.adoc' file to bitscheme, it will prepend the backquotes, execute the code blocks, and warn if the evaluated input does not match the expected output.

Comment strings (using '#') are also considered a type of Literal:
```
; 1234 # trailing comment
; #  inline comment # 4321

```

==== Expressions

Identifiers can be combined into Expressions. The default behavior is concatenation:
```
; 0b1101 0b0110
# 0b11010110
; `Hello' ` World'
# `Hello World'
```
==== Symbols

BitScheme also supports Symbolic Identifiers, which can be set
as a Name (with a dot prefix) or evaluated as a Value (without):
```
; .the-answer 42; # Name (setter)
; the-answer # Value (getter)
# 42
```
Attempts to access an undefined variable will result in a error, with a `$` prefix:
```
; ther-answer
# $ther-answer # error.undefined
```

Symbols with only non-alphanumeric characters (e.g., '+') are called Operators. There are four universal binary Operators in the standard library, which can be used with any Value:
- `?` if-then
- `:` if-else
- `&` map
- `|` reduce


=== Grouping

Grouping is done using Terminals (comma `,`, semicolon `;`, and newline `\n`) and the four pairs of Delimiters:
```
; [1, 2, 3] # Array
# [1, 2, 3]
; (0b1 0b0), # Expression
# 0b10
; .Proc {0b1 0b0}; # Deferred Expression
; .nil ();
; .all <>;
; .Bit <nil, all>; # Schema
```

==== Types

Types are just grouped expressions that are interpreted as constraints.  Some common type expressions are:

```
; .Enum <1,2,3>; # Enumerated list of valid values
; .BitField <3 Bit>; # Fixed-width sequences
; .BitStream <[Bit]>; # Arbitrary-length Arrays of a specific type

```
==== Type Errors



== Examples
